### fork和exec函数

Unix的fork函数（包括有些系统提供的它的各种变体）是Unix中派生新进程的唯一方法。
1. fork函数调用一次，返回两次，父进程返回一次，返回子进程的ID，子进程返回一次，返回的是0。
2. 父进程调用fork之前打开的所有描述符，都被子进程共享。一些网络服务器就是利用了这个特性: 父进程在accept之后，fork，所接受的已经连接的套接字就在父子进程中共享。通常情况下，子进程接着读写这个套接字，父进程则关闭这个套接字。


存放在磁盘上的可执行程序文件能够被Unix执行的唯一方法就是：由一个现有的进程调用六个exec函数中的某一个。这六个函数是：
- execl
- execv
- execle
- execve
- execlp
- execvp

他们的区别就在于如何传递参数给他们。比如：
- 参数是通过文件名还是路径名
- 参数是一个一个地提供，还是传递一个指针数组
- 把调用进程的环境传递给新程序，还是新程序使用自己的环境信息。

其实，只有execve是内核的系统调用，其他5个都是调用execve的库函数。

#### wait和waitpid函数
```c
pid_t wait(int *statloc);
pid_t wait_pid(pid_t pid, int *statloc, int options);
```
调用fork函数时，为了避免子进程变成僵尸进程，保险的做法是对SIGCHLD信息进行处置，
在信号处理函数中调用wait或者waitpid。如果有多个子进程通常应该参与非阻塞方式循环调用waitpid。

wait和waitpid他们两者的区别和联系是：

- 两者都会返回两个值：退出进程的ID和进程的退出时的状态（一个整数，通常为0表示正常退出，其他值表示异常退出）。
- wait调用时，如果有已任何退出的子进程，那么立马返回，否则如果有子进程正在运行，就阻塞，等待一个子进程终止为止。
- waitpid可以指定具体等待的子进程的ID（-1表示所有子进程）、子进程所属的用户组（0表示当前进程的用户组，-xxx表示用户组为xxx的子进程）以及可选的选项（比如WNOHANG表示不阻塞)。
- wait(&status) 等价于 waitpid(-1, &status, 0)

#### 网络编程使用fork并发时，需要注意的三件事情
1. fork子进程时，必须处理SIGCHLD信号
2. 捕获信号时，必须处理被中断的系统调用，一般是让中断的系统调用重启，比如accept, read, write等等，connect中断后不能重启。
3. SIGCHLD信号处理函数，必须正确编写，也就是循环非阻塞调用waitpid，避免留下僵尸进程。
