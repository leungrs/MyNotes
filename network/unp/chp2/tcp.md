### TCP的特点

1. 面向连接

    通过3次握手建立连接，通过4次挥手断开连接。

2. 可靠性

    通过重传来保证。如果发出的数据没有确认，那么等待一段时间后重试。如果还是没有确认，再等待更长的一点时间。等待的时间会越来越长，但是一般有一个总的时间（4-10分钟，依赖于具体的实现），超过了这个时间，就放弃重传。然后中断这个连接，通知用户。

    TCP能够动态估算客户与服务器的往返时间（Round-Trip Time， RTT）

    TCP通过给传输的每个字节编号（序列号）来保证数据的有序和完整性，并有去重功能。序列号占32位，用完了可以从新开始，循环使用。

3. TCP提供流量控制

    它告诉对端，我端一次能够接收多少字节的数据，这个称为通告窗口（advertised window）。在任何时刻该窗口指出接收缓冲区当前可用的空间量，从而确保发送端不会发送更多的数据，使得接收端的缓冲区溢出。这个窗口是动态变化的。

4. TCP是全双工的，在连接的任何一端，既可以读也可以写。


### TCP建立连接

说明：
SYN和ACK都占据一个字节的序列号空间。ACK包含的序列号，是对应的SYN的序列号加1，它也表示它接下来接收数据的序列号是多少。

1. 首先服务器必须准备好接受连接：通过socket, bind, listen来完成。
    准备好了以后，通过accept函数，进入阻塞状态，等待客户端connect。
2. 客户端调用connect函数发起连接。内核通过如下的三路握手完成连接：
    - 客户端发送SYN分节，告诉对端将在连接中发送数据的初始序列号，假设为J。通常该分节不携带数据，但是会占据一个字节的序列号空间，它只包含IP首部，TCP首部，和可能的TCP选项。比如比较常用的选项：有
        * 最大分节大小（MSS），对应的是TCP_MAXSEG参数。
        * 接收缓冲区大小，也就是窗口规模，对应SO_RCVBUF参数。
        * 时间戳，编程时无需考虑这个选项
    - 服务端确认（ACK J+1）客户端的SYN，同时自己也发送一个SYN分节，包含自己发送数据的初始序列号K。ACK和SYN在单一分节中。因此，和断开连接的4路挥手相比较，少了一次交互。
    - 最后，客户端收到服务端的SYN，也发送一个（ACK K+1）分节给服务端。
3. 服务端收到了客户端的ACK分节后，accept函数返回。连接就建立好了。

### TCP连接的终止

说明：
TCP连接需要3个分节，终止一个连接通常则需要4个分节（称为4路挥手），这是因为TCP是全双工，需要两端都关闭。但是特殊情况下，比如第二个第三个分节都是被动关闭一端的，也可以合并。

和建立连接一样，FIN和ACK也都占用一个字节的序列号空间。


1. 某一端先调用close函数，我们就称这一端执行的是主动关闭，首先发送一个FIN分节，表示这一端的数据发送完毕，不会再有数据发送了。
2. 接收到FIN的这一端执行被动关闭。这个FIN由TCP确认，同时它的接收也作为一个文件结束符（end of line）传递给接收端应用进程，放在所有其他待接收的数据的最后面。
3. 一端时间后，接收到这个FIN的应用进程，也调用close函数关闭连接，这导致它的TCP也发出一个FIN分节。
4. 接收到这个最终FIN分节的一端，也就是主动关闭的一端确认这个FIN。连接就终止了。

在步骤2和3之间，从被动关闭一端到主动关闭的一端还是可以是数据流动的。这种状态称为半关闭状态，shutdown函数和这种状态有关。

如果不是主动调用close，然后由于其他原因导致进程终止（调用exit，或者从main方法返回），那么进程将关闭它打开的所有描述符，这种情况也会导致仍然是打开状态的TCP连接上发送一个FIN。

连接建立以后，任何一端都可以先调用close，执行主动关闭。

### TCP状态转移图
TCP为一个连接定义了11种状态，并且规定了如何在当前状态下，接收到一个分节后，转移到另一个状态。

1. 首先服务端被动打开，调用listen，从CLOSED进入LISTEN状态。
2. 客户端执行主动打开，发送SYN后，从CLOSED转移到SYN_SENT状态，
   服务端收到SYN后，从LISTEN进入到SYN_RCVD状态。
3. 客户端的收到对端的带有ACK和SYN分节，同时发送ACK后，从SYN_SENT转移到ESTABLISHED状态，
   服务端收到客户端的ACK后，从SYN_RCVD进入到ESTABLISHED状态。

通过上面上面3次握手的步骤，两端都进入了ESTABLISHED状态，在该状态下进行数据的传输。

- 客户端：
  CLOSED -> SYN_SEND -> ESTABLISHED
- 服务端：
  CLOSED -> LISTEN -> SYN_RCVD -> ESTABLISHED

4. 数据传输完成后，首先执行close的一端，也就是主动关闭端，发送FIN，从ESTABLISHED进入到FIN_WAIT_1状态。接收到对FIN的ACK后，从FIN_WAIT_1转移到FIN_WAIT_2状态。
5. 收到FIN的一端，也就是被动关闭端，从ESTABLISHED转移到CLOSE_WAIT状态。
6. 被动关闭端传输完数据后，也发送一个FIN，从CLOSE_WAIT转移到LAST_WAIT状态。
   被动关闭端收到ACK后，从LAST_WAIT转移到CLOSED状态。
7. 主动关闭端，收到被动关闭端的FIN后，发送确认ACK，从FIN_WAIT_2转移到TIME_WAIT状态。
   经过2MSL超时后，主动关闭端从从TIME_WAIT进入到CLOSED状态。

因此：

- 主动关闭端：
  FIN_WAIT_1 -> FIN_WAIT_2 -> TIME_WAIT -> CLOSED
- 被动关闭端：
  CLOSE_WAIT -> LAST_WAIT -> CLOSED


上面是正常情况下的转移图，极少情况下，会发生两端同时发送FIN的情况，此时两端都同时进入FIN_WAIT_1状态，收到对端的FIN后，并且发送ACK后，同时进入CLOSING状态，收到ACK后进入TIME_WAIT状态。
也就是客户端和服务端的状态都是：

FIN_WAIT_1 -> CLOSING -> TIME_WAIT -> CLOSED

总结11中状态为：
- CLOSED
- LISTEN
- SYN_SENT
- SYN_RCVD
- ESTABLISHED
- FIN_WAIT_1
- FIN_WAIT_2
- CLOSE_WAIT
- LAST_WAIT
- TIME_WAIT
- CLOSING

#### TIME_WAIT状态
TIME_WAIT状态存在的理由：
- 可靠地实现TCP全双工连接的终止
- 允许老的重复的分节在网络中消逝，因为处于TIME_WAIT状态的连接所占用的IP和端口号，不能被重复利用。
